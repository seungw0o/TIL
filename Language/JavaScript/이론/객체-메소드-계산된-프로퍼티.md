## 계산된 프로퍼티(Computed property)

```jsx
let a = "age";

const user = {
  name: "Mike",
  [a]: 20
};

const user1 = {
  [1 + 5]: 5, // 5 : 5
  ["안녕" + "하세요"]: "Hello" // 안녕하세요 : 'Hello'
};
```

## 객체 메소드

### `Object.assign()` : 객체 복제

```jsx
const user = {
  name: "Mike",
  age: 20
};

const cloneUser = user; //이렇게 하면 cloneUser와 user는 같은 객체의 참조 값을 가지고 있음

cloneUser.name = "Tom";
// user.name === 'Tom' | cloneUser의 name을 바꾸면 user의 name도 바뀜

const newUser = Object.assign({}, user);
// 첫번째 인자 {}에 user 객체가 병합되어서 복제된다

newUser.name = "Tom";
console.log(user.name); // Mike
newUser !== user;

Object.assign({ gender: "male" }, user);
// gender 값을 가진 객체가 복제됨

Object.assign({ name: "Tom" }, user);
// Tom이라는 name 값을 덮어쓰게 되어서 Mike라는 name을 가진 객체가 복제됨

Object.assign(user1, user2, user3);
// user1에 user2, user3이 추가된 객체가 복제된다
```

### `Object.keys()` : 키 배열 반환

```jsx
const user = {
  name: "Mike",
  age: 20,
  gender: "male"
};

Object.keys(user);
// ['name', 'age', 'gender']
```

### `Object.values()` : 값 배열 반환

```jsx
const user = {
  name: "Mike",
  age: 20,
  gender: "male"
};

Object.values(user);
// ['Mike', 30, 'male']
```

### `Object.entries()` : 키/값 배열 반환

```jsx
const user = {
  name: "Mike",
  age: 20,
  gender: "male"
};

Object.entries(user);
/* [key, value] 형태로 이루어진 배열을 반환함
[
	['name', 'Mike'], 
	['age', 30],
	['gender', 'male'],
]
*/
```

### `Object.fromEntries()` : 키/값 배열을 객체로

```jsx
const arr = [
  ["name", "Mike"],
  ["age", 30],
  ["gender", "male"]
];

Object.fromEntries(arr);
/* [key, value] 형태로 이루어진 배열 객체로 변환
{
	name : 'Mike',
	age : 20,
	gender : 'male',
}
*/
```
