# Event Loop

## Event Loop의 시각적 표현

<img src='https://developer.mozilla.org/ko/docs/Web/JavaScript/Event_loop/the_javascript_runtime_environment_example.svg' alt='Event Loop'>;

## Stack

- 함수의 호출들은 '프레임' 스택을 형성한다.

- 예시 코드

  ```jsx
  function foo(b) {
    const a = 10;
    return a + b + 11;
  }

  function bar(x) {
    const y = 3;
    return foo(x * y);
  }

  const baz = bar(7); // 42를 baz에 할당
  ```

  예시 코드의 실행 순서

  1. 함수 bar을 호출할 때, bar의 인수와 지역 변수에 대한 참조를 포함하는 첫 번째 프레임이 생성된다.
  2. bar가 foo를 호출할 때, foo의 인수와 지역 변수에 대한 참조를 포함하는 두번째 프레임이 생성되고, 첫번째 프레임 위로 추가된다.
  3. foo가 반환되면, 맨 위의 프레임 요소를 스택 밖으로 꺼낸다(bar 호출 프레임만 남게된다.)
  4. bar가 반환되면, 스택이 비어있게 된다.

인수와 지역 변수는 스택 바깥에 저장되니, 바깥 함수가 반환되어도 계속 존재하니 유의하자

## Heap

- 객체는 힙에 할당된다. 힙은 단순히 메모리의 큰 영역을 지칭하는 용어이다.

## Queue

- JavaScript 런타임은 메시지 큐, 처리할 메시지의 대기열을 사용한다. 각각의 메시지에는 메시지를 처리하기 위한 함수가 연결 되어있다.

- 이벤트 루프의 임의 시점에, 런타임은 대기열에서 가장 오래된 메시지부터 큐에서 꺼내 처리하기 시작한다. 이를 위해서 런타임은 꺼낸 메시지를 매개변수로, 메시지에 연결된 함수를 호출한다. 함수를 호출하면 해당 함수가 사용할 새로운 스택 프레임이 생성된다.

- 함수 처리는 스택이 다시 텅 빌 때까지 계속된다. 그 후, 큐에 메시지가 남아 있다면, 같은 방법으로 처리한다.

## Event Loop

- 앞에 있는 기능들을 구현할 때, 보통 사용하는 방식에서 그 이름을 얻었으며, 다음과 같은 형태이다.
  ```jsx
  while (queue.waitForMessage()) {
    queue.processNextMessage();
  }
  ```
  - queue.waitForMessage() 함수는 현재 처리할 수 있는 메시지가 존재하지 않으면 새로운 메시지가 도착할때까지, 동기적으로 대기하는 함수를 말한다.

## Run-to-completion

- 각 메시지 처리는 다른 메시지 처리를 시작하기 전에 완전히 끝난다.
  (비동기?)

- 이 특징은 프로그램의 동작을 추론할 때, 유용한 특성을 제공한다. 실행한 함수가 다른 작업에 의해 선점될 일이 없고, 다른 모든 코드의 실행보다 우선해서 값을 변경할 수 있다. 왜냐하면 중단되는 일 없이 완전히 끝나기 때문이다. 반면에 C언어에서는, 스레드에서 실행 중인 함수를 런타임 시스템이 임의로 중단시키고 다른 스레드의 다른 코드를 실행 시킬 수 있다.

### 단점?

- 단점으로는 메시지를 처리하는 과정이 너무 오래 걸리면, 클릭이나 스크롤 같은 사용자 상호작용을 처리 할 수 없다는 점이 있다. 브라우저는 '스크립트 응답 없음' 이라는 창을 표시하여 이 문제를 완화 시킨다. 이러한 단점을 해결하기 위해, 개발자는 메시지 처리를 가볍게 유지하고, 가능하다면 하나의 메시지를 여러개로 나누는 것이다.

## 메시지 추가하기

- 웹 브라우저에서는 클릭 이벤트 처리기가 붙은 요소를 클릭하면, 메시지가 새로 추가된다. 다른 이벤트에 대해서도 마찬가지다.

### setTimeout() 함수?

- 두개의 매개변수를 가지는 함수이다. 첫 번째는 큐에 추가할 메시지, 두 번째는 시간 값(선택 사항, 기본 값 : 0). 시간 값은 메시지를 큐에 추가하기까지 기다릴 (최소) 지연 시간을 나타낸다. 큐에 다른 메시지가 없고, 스택도 비어있다면, setTimeout의 메시지는 딜레이 직후 바로 처리된다. 그러나 앞에 다른 메시지가 존재한다면, setTimeout은 앞선 메시지의 처리를 기다려야한다. 그래서 시간 값은 지연 시간이 아닌 (최소) 지연 시간을 나타낸다.

### 0의 지연 시간

- 지연 시간을 0으로 지정한다고 해도, 바로 실행 되는 것은 아니다. 앞선 메시지가 있다면, 그 메시지를 먼저 처리하기 때문이다. 그렇기 때문에 지연 시간은 (최소) 지연 시간인 것이다.
